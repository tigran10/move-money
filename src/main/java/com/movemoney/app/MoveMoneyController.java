package com.movemoney.app;

import com.google.inject.Inject;
import com.movemoney.app.dto.AccountData;
import com.movemoney.app.dto.MoveMoneyInstruction;
import com.movemoney.domain.Account;
import com.movemoney.storage.Storage;
import io.vavr.control.Try;
import io.vertx.core.AsyncResult;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.Message;
import io.vertx.core.json.Json;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

import java.util.logging.Logger;

import static io.netty.handler.codec.http.HttpResponseStatus.*;


public class MoveMoneyController {
    private final static Logger LOGGER = Logger.getLogger("MoveMoneyController");

    private final Vertx vertx;
    private final Storage storage;
    private Router router;


    @Inject
    public MoveMoneyController(Vertx vertx, Storage storage) {
        this.storage = storage;
        this.vertx = vertx;
    }


    public Router getRouter() {
        if (router == null) {
            router = Router.router(vertx);

            router.post("/accounts").handler(this::createAccount);
            router.get("/accounts").handler(this::getAccounts);
            router.get("/accounts/:id").handler(this::findAccount);
            router.get("/accounts/:id/transactions").handler(this::findTransactions);

            router.post("/movemoney").handler(this::doTransfer);
        }

        return router;
    }

    private void findTransactions(RoutingContext ctx) {
        String id = ctx.request().getParam("id");

        vertx.executeBlocking(
                fut -> fut.complete(storage.findTransactions(new Account.Id(id))),
                false,
                res -> handleAsyncResponse(res, ctx, OK.code())
        );
    }

    private void getAccounts(RoutingContext ctx) {
        vertx.executeBlocking(
                fut -> fut.complete(storage.findAccounts()),
                false,
                res -> handleAsyncResponse(res, ctx, OK.code())
        );
    }

    private void findAccount(RoutingContext ctx) {
        String id = ctx.request().getParam("id");

        vertx.executeBlocking(
                fut -> storage.findAccount(new Account.Id(id))
                        .ifPresentOrElse(
                                fut::complete,
                                () -> notFound(ctx)
                        ),
                false,
                res -> handleAsyncResponse(res, ctx, OK.code())
        );
    }

    private void createAccount(RoutingContext ctx) {
        final AccountData accountData = Json.decodeValue(
                ctx.getBodyAsString(),
                AccountData.class);

        vertx.executeBlocking(
                fut -> {
                    var account = Account.of(
                            Account.Id.autoGenerated(),
                            accountData.getFirstName(),
                            accountData.getOngoingBalance());

                    storage.createAccount(account);
                    fut.complete(account);
                },
                false,
                res -> handleAsyncResponse(res, ctx, CREATED.code())
        );
    }


    private void doTransfer(RoutingContext ctx) {

        final MoveMoneyInstruction moveMoneyInstruction = Json.decodeValue(
                ctx.getBodyAsString(),
                MoveMoneyInstruction.class);

        vertx.eventBus().send(Events.MOVEMONEY, moveMoneyInstruction, res -> {
            handleEventBusResponse(CREATED.code(), res, ctx);
        });
    }


    private void handleAsyncResponse(AsyncResult<Object> res, RoutingContext ctx, int status) {
        if (res.succeeded()) {
            Try.run(() -> ctx.response().setStatusCode(status).end(Json.encode(res.result())))
                    .onFailure(exc -> ctx.fail(new RuntimeException("Failed to encode results.")));
        } else {
            ctx.fail(res.cause());
        }
    }


    private void handleEventBusResponse(Integer successStatus, AsyncResult<Message<Object>> res, RoutingContext ctx) {
        if (res.succeeded()) {
            ctx.response().setStatusCode(successStatus).end(res.result().body().toString());
        } else {
            ctx.fail(res.cause());
        }
    }

    private void notFound(RoutingContext context) {
        context.response().setStatusCode(NOT_FOUND.code()).end();
    }
}