package com.movemoney.service

import com.movemoney.app.dto.MoveMoneyInstruction
import com.movemoney.app.dto.MoveMoneyResult
import com.movemoney.domain.Account
import com.movemoney.domain.ReentrantAccountLocker
import io.vavr.control.Try
import spock.lang.Specification

import java.util.concurrent.*

import static com.movemoney.service.Fixtures.*

class TransactionManagerConcurrencyTest extends Specification {

    ReentrantAccountLocker locker = new ReentrantAccountLocker()
    ExecutorService executor = Executors.newFixedThreadPool(3);

    def "TransactionManager should lock accounts while processing the transaction"() {
        given: "two transaction managers, slow and fast are using same locking mechanism"
        TransactionManager transactionManagerSlow = new TransactionManager(new SlowStorage(), locker)
        TransactionManager transactionManagerFast = new TransactionManager(new FastStorage(), locker)



        when: "slow transaction manager tries to move money"
        Future<Try<MoveMoneyResult>> first = executor.submit(new Callable<Try<MoveMoneyResult>>() {
            @Override
            Try<MoveMoneyResult> call() throws Exception {
                println "starting slow transaction manager"
                transactionManagerSlow.moveMoney(new MoveMoneyInstruction(borisId, theresaId, ten))
            }
        })

        Thread.sleep(100)

        and: "fast transaction managers tries to move money for same people"
        Future<Try<MoveMoneyResult>> second = executor.submit(new Callable<Try<MoveMoneyResult>>() {
            @Override
            Try<MoveMoneyResult> call() throws Exception {
                println "starting fast transaction manager"
                transactionManagerFast.moveMoney(new MoveMoneyInstruction(borisId, theresaId, ten))
            }
        })
        second.get(2, TimeUnit.SECONDS)


        then: "then timeout exception happen"
        thrown TimeoutException

    }


    def "TransactionManager should NOT lock different accounts while processing the transactions"() {
        given: "two transaction managers, slow and fast are using same locking mechanism"
        TransactionManager transactionManagerSlow = new TransactionManager(new SlowStorage(), locker)
        TransactionManager transactionManagerFast = new TransactionManager(new FastStorage(), locker)


        when: "slow transaction manager tries to move money"
        Future<Try<MoveMoneyResult>> first = executor.submit(new Callable<Try<MoveMoneyResult>>() {
            @Override
            Try<MoveMoneyResult> call() throws Exception {
                println "starting slow transaction manager"
                transactionManagerSlow.moveMoney(new MoveMoneyInstruction(borisId, theresaId, ten))
            }
        })

        Thread.sleep(100)

        and: "fast transaction managers tries to move money for different people"
        Future<Try<MoveMoneyResult>> second = executor.submit(new Callable<Try<MoveMoneyResult>>() {
            @Override
            Try<MoveMoneyResult> call() throws Exception {
                println "starting fast transaction manager"
                transactionManagerFast.moveMoney(new MoveMoneyInstruction(Account.Id.autoGenerated(), Account.Id.autoGenerated(), ten))
            }
        })
        def get = second.get(100, TimeUnit.SECONDS)


        then: "then fast one completes"
        get.isFailure()

    }


}